    Two new words add to the word "compiler" abilities of
    the interpreter:

        IMMEDIATE  sets the latest word to be "immediate"
        HIDE       takes the next "word" of input, looks it up
                   in the dictionary, and then sets that word
                   to be hidden (via the word HIDDEN)

    HIDE seems the easiest to test, so we'll start with that:

: emit2 EMIT EMIT ;
66 65 emit2
AB
HIDE emit2
66 65 emit2
PARSE ERROR: 66 65 emit2

    That worked: we get the parse error because emit2 has been
    hidden and is no longer found in the dictionary.

    The HIDDEN word used by HIDE actually toggles the hidden state,
    so can we call HIDE again to unhide the word?

HIDE emit2

Program received signal SIGSEGV, Segmentation fault.
code_HIDDEN () at nasmjf.asm:635
635         xor [edi], word F_HIDDEN  ; Toggle the HIDDEN bit in place.

    Oh, ha ha, no, of course not. It's hidden, so HIDE can't
    find it (and since there's absolutely no error checking,
    we crash trying to toggle the bit in some random memory
    location).

    I guess we could use LATEST and HIDDEN to manually toggle
    it back, but I can't be bothered tonight.

    Onward to IMMEDIATE.

: ab 66 65 EMIT EMIT ;
IMMEDIATE
: foo 1000 . ;
foo
foo
55 EMIT
;

^C
Program received signal SIGINT, Interrupt.
_WORD.skip_non_words () at nasmjf.asm:339
339         call _KEY               ; get next key, returned in %eax

   Something went wrong. I had to Ctrl+C to end the
   program. It was merrily taking input, but nothing
   would execute, not even Ctrl+D to end the input
   and exit.

   Let's try that again and verify we're toggling the
   right word...

(gdb) r
Starting program: /home/dave/nasmjf/nasmjf
(gdb) c
Continuing.
LATEST 4 + C@ .
6
LATEST 5 + C@ EMIT
L

    Okay, just sanity checking LATEST - it points to
    a word with 6 letters in the name and starts with
    the letter "L" (it's LATEST itself).

    I'll define my 'ab' word again, try it out (it should
    print the letters "AB"), and check LATEST again...

: ab 66 65 EMIT EMIT ;
ab
AB
LATEST 4 + C@ .
2
LATEST 5 + C@ EMIT
a
IMMEDIATE
ab

    Drat! Then it locked up again. So IMMEDIATE is
    definitely not working right.

    Next night: okay, let's see what's going on...

(gdb) break code_IMMEDIATE
Breakpoint 2 at 0x80494ec: file nasmjf.asm, line 1097.
(gdb) c
Continuing.
: ab 66 65 EMIT EMIT ;
ab
AB
IMMEDIATE

Breakpoint 2, code_IMMEDIATE () at nasmjf.asm:1097
(gdb) p/x (int)var_LATEST
$1 = 0x804e000
(gdb) x/10c (int)var_LATEST
0x804e000:   ...  2 '\002' 97 'a'  98 'b' ...

    So that's right - LATEST points at word 'ab'...

1098        add edi, 4                ; Point to name/flags byte.
1099        xor byte [edi], F_IMMED   ; Toggle the IMMED bit.
(gdb) p/x $edi
$2 = 0x804a6b0

    That's a dead giveaway, the address in register
    edi should now be LATEST + 4.  But it's actually
    the _address_ of LATEST + 4!

(gdb) p/x (int)var_LATEST
$3 = 0x804e000

    It still takes me a bit before I see it...

(gdb) disass 1099
No function contains specified address.
(gdb) disass code_IMMEDIATE
Dump of assembler code for function code_IMMEDIATE:
   0x080494ec <+0>:     mov    edi,0x804a6ac   <--- should be PTR
   0x080494f1 <+5>:     add    edi,0x4
=> 0x080494f4 <+8>:     xor    BYTE PTR [edi],0x80
   0x080494f7 <+11>:    lods   eax,DWORD PTR ds:[esi]
   0x080494f8 <+12>:    jmp    DWORD PTR [eax]
End of assembler dump.

    I finally see it.

    I have

        mov edi, var_LATEST

    where I should have

        mov edi, [var_LATEST]

    (so of course it wasn't working after that. LATEST was
    incremented and no longer pointed at word. All further
    interpretation would fail to match!)

    With that fixed, it should work...

(gdb) load
(gdb) r
Starting program: /home/dave/nasmjf/nasmjf
: ab 66 65 EMIT EMIT ;
ab
AB
IMMEDIATE

    So now 'ab' should execute as soon as the interpreter
    sees it, even in compile mode:

: five 5 . ab ;
AB
five
5

    Yeah! The call to 'ab' executed at "compile time" rather
    than "run time" for the new word 'five'. Using this, we
    could add new language features to FORTH in FORTH.



