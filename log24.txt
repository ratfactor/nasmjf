    This log starts with neat stuff: checking and allocating
    memory!

    Memory alloction in Forth couldn't be less complicated.
    The application has some amount of memory upon startup.
    As you use it for variables, constants, strings, and new
    word definitions, the HERE pointer advances to the next
    unused spot.

    You check how much memory is left with UNUSED and
    request more with the deliciously retro-sounding command
    MORECORE.

    In this Linux interpreter, memory checking and
    allocation is handled with the brk system call.

    The "break" address (end of memory allocated for us by
    Linux) minus HERE gives us the amount of unused memory:

JONESFORTH VERSION 1
20643 CELLS REMAINING
OK
GET-BRK .
151916544
HERE .
134522628
UNUSED .
20643

    That checks out. Let's add a bit more:

1024 MORECORE
UNUSED .
21667

    Sweet!

    I did not have very much fun with the file io words.
    Though I did manage to create an empty file with:

S" foo.txt" R/W CREATE-FILE
CLOSE-FILE
BYE
$ ls
foo.txt

    But I'm not sure what to do with a file descriptor for
    writing. Words like TELL are hard-coded to use STDOUT.

    Eh, no big deal. Learning how to read and write files is
    not one of goals here. :-)

    But you know what _is_ a big deal? The proof-of-concept
    assembler implemented near the end of jonesforth.f:

        ;CODE - ends a colon word like usual, but it
                appends a machine code NEXT (just like
                our NEXT macro in NASM) and then alters
                the "codeword" link in the just-compiled
                word to point to the "data" we compiled
                into the word definition.

    You use it like so:

        : foo <machine code/assembly> ;CODE

    Then Jones defines some assembly mnemonics for things
    like the registers EAX, ECD, EDX, etc. and assembly
    mnemonics for PUSH and POP.

    Finally, a fun instruction for the Pentium (and later)
    x86 CPUs, RDTSC that returns 64 bits worth of clock
    cycles.

    The assembled word that makes use of the mnemonics looks
    like this:


        : RDTSC ( -- lsb msb )
                RDTSC        ( writes the result in %edx:%eax )
                EAX PUSH     ( push lsb )
                EDX PUSH     ( push msb )
        ;CODE

    Let's try it!

RDTSC . .
7 193238564
RDTSC DROP RDTSC DROP SWAP - .
8815
RDTSC DROP RDTSC DROP SWAP - .
9068

    I'm dropping the most significant bytes since I'm
    measuring smaller amounts of time (which wouldn't be
    correct if the least significant bytes rolled over!)

    Apparently a couple instructions takes over 8,000 CPU
    cycles? Very interesting!

    









