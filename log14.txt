    First, we've got some horrible failure in ADD (+) to
    fix:

6 6 + .
134914672

    Sure enough, I was doing this

        pop byte [eax]

    instead of this

        pop eax

    for reasons involving being very sleepy.

    Is it fixed with the right stack poppin'?

5 5 + .
10
33 7 + .
40

    Yup! Now continuing on, we've got a bunch of comparison
    operators - some of them seem downright silly. But Leo
    Brodie explains in Starting Forth that having all these
    means smaller word definitions (space being paramount on
    those original systems) and potentially faster.

    I'll put the answers on the same line to make it much
    easier to read (and many FORTH systems would have displayed
    the response on the same line anyway, so this output is
    super authentic).

4 4 = .   1
5 4 = .   0
4 4 <> .  0
5 4 <> .  1
7 3 < .   0
3 7 < .   1
7 3 > .   1
3 7 > .   0
7 3 >= .  1
3 3 >= .  1
4 3 >= .  1
7 3 <= .  0
3 3 <= .  1
5 0= .    0
0 0= .    1
5 0<> .   1
0 0<> .   0
5 0< ..   PARSE ERROR: 5 0< ..
5 0< .    0
-5 0< .   1
5 0> .    1
-5 0> .   0
0 0> .    0
5 0>= .   1
0 0>= .   1
-7 0>= .  0
-7 0<= .  1
0 0<= .   1
7 0<= .   0

    I left in that fat-fingered '..' to break up the monotony.
    But you can see how these work. The comparisons expect
    either 1 or 2 numbers on the stack. They leave a 1 for
    true and 0 for false.
